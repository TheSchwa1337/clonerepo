# -*- coding: utf-8 -*-
"""
Clean Trading Pipeline for Schwabot System.

This module provides a clean, working implementation of the unified trading
pipeline that integrates all components while maintaining proper code structure
and error handling.
"""

import asyncio
import uuid
from decimal import Decimal
from typing import Any, Dict, List, Optional, Union, Tuple

import logging
import time
from enum import Enum
from dataclasses import dataclass, field
from pathlib import Path
import numpy as np


from .clean_math_foundation import BitPhase, CleanMathFoundation, ThermalState
from .clean_profit_vectorization import CleanProfitVectorization, ProfitVector, VectorizationMode
from .strategy_bit_mapper import StrategyBitMapper, ExpansionMode
from .portfolio_tracker import PortfolioTracker
from .ccxt_trading_executor import CCXTTradingExecutor, IntegratedTradingSignal, TradingPair
from .phase_bit_integration import phase_bit_integration
from .unified_math_system import create_unified_math_system, UnifiedMathSystem
from .zpe_zbe_core import (
    ZPEZBECore, ZPEVector, ZBEBalance, QuantumSyncStatus,
    QuantumPerformanceEntry, QuantumPerformanceRegistry,
    ZPEZBEPerformanceTracker, create_zpe_zbe_core
)
from .chrono_recursive_logic_function import (
    ChronoRecursiveLogicFunction, CRLFState, CRLFResponse, CRLFTriggerState, create_crlf
)
from .soulprint_registry import SoulprintRegistry
from .unified_market_data_pipeline import UnifiedMarketDataPipeline, create_unified_pipeline, MarketDataPacket


logger = logging.getLogger(__name__)


class TradingAction(Enum):
    """Trading actions."""

    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"


class StrategyBranch(Enum):
    """Strategy branches."""

    MEAN_REVERSION = "mean_reversion"
    MOMENTUM = "momentum"
    ARBITRAGE = "arbitrage"
    SCALPING = "scalping"
    SWING = "swing"
    GRID = "grid"
    FERRIS_WHEEL = "ferris_wheel" # Add Ferris Wheel as a strategy branch


class MarketRegime(Enum):
    """Market regimes."""

    TRENDING_UP = "trending_up"
    TRENDING_DOWN = "trending_down"
    SIDEWAYS = "sideways"
    VOLATILE = "volatile"
    CALM = "calm"


@dataclass
class MarketData:
    """Market data snapshot."""

    symbol: str
    price: float
    volume: float
    timestamp: float
    bid: Optional[float] = None
    ask: Optional[float] = None
    volatility: float = 0.5
    trend_strength: float = 0.5
    entropy_level: float = 4.0
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class TradingDecision:
    """Trading decision output."""

    timestamp: float
    symbol: str
    action: TradingAction
    quantity: float
    price: float
    confidence: float
    strategy_branch: StrategyBranch
    profit_potential: float
    risk_score: float
    thermal_state: ThermalState
    bit_phase: BitPhase
    profit_vector: ProfitVector
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class PipelineState:
    """Current state of the trading pipeline."""

    timestamp: float
    active_strategy: StrategyBranch
    current_capital: float
    total_trades: int
    winning_trades: int
    losing_trades: int
    total_profit: float
    current_risk_level: float
    market_regime: MarketRegime
    thermal_state: ThermalState
    bit_phase: BitPhase
    last_market_data: Optional[MarketData] = None


@dataclass
class ZPEZBEPipelineState:
    """Enhanced pipeline state with ZPE-ZBE tracking."""
    
    base_state: PipelineState
    current_zpe_energy: float
    current_zbe_status: float
    quantum_sync_status: QuantumSyncStatus
    quantum_potential: float
    system_entropy: float
    performance_registry: QuantumPerformanceRegistry
    last_zpe_analysis: Optional[Dict[str, Any]] = None
    last_zbe_analysis: Optional[Dict[str, Any]] = None


@dataclass
class CRLFEnhancedPipelineState:
    """Pipeline state enhanced with CRLF tracking."""
    
    base_state: PipelineState
    crlf_instance: ChronoRecursiveLogicFunction
    current_crlf_output: float
    current_trigger_state: CRLFTriggerState
    strategy_alignment_trend: List[float]
    temporal_resonance_history: List[float]
    recursion_depth_history: List[int]
    last_crlf_analysis: Optional[Dict[str, Any]] = None



@dataclass
class ZPEZBEMarketData:
    """Enhanced market data with ZPE-ZBE analysis."""
    
    base_market_data: MarketData
    zpe_vector: ZPEVector
    zbe_balance: ZBEBalance
    quantum_sync_status: QuantumSyncStatus
    quantum_potential: float
    resonance_factor: float
    strategy_confidence: float
    soulprint_vector: Dict[str, float]
    metadata: Dict[str, Any] = field(default_factory=dict)



@dataclass
class CRLFEnhancedMarketData:
    """Market data enhanced with CRLF analysis."""
    
    base_market_data: MarketData
    crlf_response: CRLFResponse
    strategy_alignment_score: float
    temporal_resonance: float
    recursion_depth: int
    trigger_state: CRLFTriggerState
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class CRLFEnhancedTradingDecision:
    """Trading decision enhanced with CRLF analysis."""
    
    base_decision: TradingDecision
    crlf_output: float
    trigger_state: CRLFTriggerState
    strategy_alignment: float
    temporal_urgency: str
    recursion_depth: int
    risk_adjustment: float
    strategy_weights: Dict[str, float]
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class ZPEZBETradingDecision:
    """Enhanced trading decision with ZPE-ZBE analysis."""
    
    base_decision: TradingDecision
    zpe_energy: float
    zbe_status: float
    quantum_sync_status: QuantumSyncStatus
    quantum_potential: float
    strategy_confidence: float
    recommended_action: str
    risk_adjustment: float
    system_entropy: float
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class RiskParameters:
    """Risk management parameters."""

    max_position_size: float = 0.1  # 10% max position
    stop_loss_pct: float = 0.02  # 2% stop loss
    take_profit_pct: float = 0.04  # 4% take profit
    max_daily_loss: float = 0.05  # 5% max daily loss
    volatility_threshold: float = 0.8  # High volatility threshold
    correlation_threshold: float = 0.9  # High correlation threshold


class CleanTradingPipeline:
    """
    Clean trading pipeline that integrates all Schwabot components.

    This pipeline provides:
    - Mathematical foundation for all calculations
    - Profit vectorization with multiple modes
    - Strategy switching based on market conditions
    - Risk management and position sizing
    - Real-time market analysis and decision making
    """

    def __init__(
        self,
        symbol: str = "BTCUSDT",
        initial_capital: float = 10000.0,
        risk_params: Optional[RiskParameters] = None,
        matrix_dir: Union[str, Path] = "data/matrices",
        registry_file: Optional[str] = None,
        pipeline_config: Optional[Dict[str, Any]] = None
    ):
        """Initialize the trading pipeline."""
        self.symbol = symbol
        self.initial_capital = initial_capital
        self.risk_params = risk_params or RiskParameters()

        # Initialize mathematical foundation
        self.math_foundation = CleanMathFoundation()

        # Initialize profit vectorization
        self.profit_vectorizer = CleanProfitVectorization()

        # Initialize StrategyBitMapper for Ferris Wheel and other expansions
        self.matrix_dir = Path(matrix_dir)
        self.strategy_bit_mapper = StrategyBitMapper(matrix_dir=self.matrix_dir)

        # Initialize PortfolioTracker (assuming it handles real portfolio data eventually)
        self.portfolio_tracker = PortfolioTracker()  # Placeholder until actual implementation is verified

        # Initialize CCXTTradingExecutor (needs a proper config for live trading)
        self.ccxt_executor = CCXTTradingExecutor(config={
            "exchange": "binance", # Example: configure for your exchange
            "apiKey": "YOUR_API_KEY",
            "secret": "YOUR_SECRET_KEY",
        })

        # Initialize PhaseBitIntegration for dualistic state analysis
        self.phase_bit_integration = phase_bit_integration

        # Initialize ZPE-ZBE Core and Unified Math System
        self.zpe_zbe_core = create_zpe_zbe_core()
        self.unified_math_system = create_unified_math_system()

        # Pipeline state
        self.state = PipelineState(
            timestamp=time.time(),
            active_strategy=StrategyBranch.MOMENTUM,
            current_capital=initial_capital,
            total_trades=0,
            winning_trades=0,
            losing_trades=0,
            total_profit=0.0,
            current_risk_level=0.0,
            market_regime=MarketRegime.SIDEWAYS,
            thermal_state=ThermalState.WARM,
            bit_phase=BitPhase.EIGHT_BIT,
        )


        # Initialize ZPE-ZBE Performance Tracker
        self.zpe_zbe_performance_tracker = ZPEZBEPerformanceTracker()
        
        # Enhanced pipeline state with ZPE-ZBE tracking

        # Initialize Chrono-Recursive Logic Function
        self.crlf = create_crlf()
        
        # Enhanced pipeline state with CRLF tracking
        self.crlf_enhanced_state = CRLFEnhancedPipelineState(
            base_state=self.state,
            crlf_instance=self.crlf,
            current_crlf_output=0.0,
            current_trigger_state=CRLFTriggerState.HOLD,
            strategy_alignment_trend=[],
            temporal_resonance_history=[],
            recursion_depth_history=[]
        )

        self.zpe_zbe_state = ZPEZBEPipelineState(
            base_state=self.state,
            current_zpe_energy=0.0,
            current_zbe_status=0.0,
            quantum_sync_status=QuantumSyncStatus.UNSYNCED,
            quantum_potential=0.0,
            system_entropy=0.0,
            performance_registry=QuantumPerformanceRegistry()
        )

        # Market data history for analysis
        self.market_data_history: List[MarketData] = []
        self.decision_history: List[TradingDecision] = []

        # Performance tracking
        self.performance_metrics = {
            "total_return": 0.0,
            "sharpe_ratio": 0.0,
            "max_drawdown": 0.0,
            "win_rate": 0.0,
            "profit_factor": 0.0,
        }

        self.registry_file = registry_file
        self.registry = None
        if registry_file:
            self.registry = SoulprintRegistry(registry_file)
        
        # Initialize unified market data pipeline
        self.pipeline_config = pipeline_config or self._default_pipeline_config()
        if registry_file:
            self.pipeline_config["registry_file"] = registry_file
        self.market_pipeline = create_unified_pipeline(self.pipeline_config)
        
        logger.info(f"Trading pipeline initialized with unified market data for {symbol}")

    def _default_pipeline_config(self) -> Dict[str, Any]:
        """Default configuration for market data pipeline."""
        return {
            "cache_ttl": 60,  # 1 minute cache for live trading
            "max_price_history": 2000,
            "api_timeout": 15,
            "retry_attempts": 2,
            "failover_enabled": True,
            "quality_threshold": 0.5,  # Lower threshold for live trading
            "apis": {
                "coingecko": {"enabled": True, "weight": 0.5},
                "glassnode": {"enabled": True, "weight": 0.3},
                "fear_greed": {"enabled": True, "weight": 0.2}
            }
        }
    
    async def process_market_data(self, market_data: Optional[Dict] = None, force_refresh: bool = False) -> Optional[Dict]:
        """
        Process market data through unified pipeline and execute trading logic.
        
        Args:
            market_data: Optional manual market data (for testing)
            force_refresh: Force refresh from APIs
            
        Returns:
            Trade result dictionary
        """
        try:
            # Get unified market data
            if market_data:
                # Use provided market data for testing
                processed_data = market_data
                market_packet = None
            else:
                # Get data from unified pipeline
                symbol_base = self.symbol.replace("USDT", "").replace("USD", "")
                market_packet = await self.market_pipeline.get_market_data(symbol_base, force_refresh=force_refresh)
                
                # Convert to trading pipeline format
                processed_data = self._convert_market_packet_to_legacy_format(market_packet)
            
            # Calculate trading signals using enhanced data
            signals = self._calculate_enhanced_trading_signals(market_packet, processed_data)
            
            # Risk assessment with market data
            risk_assessment = self._assess_risk_with_market_data(market_packet, signals)
            
            # Determine trade action
            trade_action = self._determine_trade_action(signals, risk_assessment)
            
            # Execute trade if action required
            trade_result = None
            if trade_action["action"] != "hold":
                trade_result = await self._execute_trade_with_market_data(
                    trade_action, market_packet, processed_data
                )
                
                # Log to registry if enabled
                if self.registry and market_packet and trade_result:
                    self._log_trade_to_registry(market_packet, trade_action, trade_result)
            
            return {
                "timestamp": time.time(),
                "symbol": self.symbol,
                "market_data": processed_data,
                "market_packet": market_packet.__dict__ if market_packet else None,
                "signals": signals,
                "risk_assessment": risk_assessment,
                "trade_action": trade_action,
                "trade_result": trade_result,
                "pipeline_metrics": self.market_pipeline.get_pipeline_status()
            }
            
        except Exception as e:
            logger.error(f"Error processing market data: {e}")
            return None
    
    def _convert_market_packet_to_legacy_format(self, packet: MarketDataPacket) -> Dict[str, Any]:
        """Convert MarketDataPacket to legacy format for existing pipeline compatibility."""
        return {
            "symbol": packet.symbol,
            "price": packet.price,
            "volume": packet.volume_24h,
            "market_cap": packet.market_cap,
            "price_change_24h": packet.price_change_24h,
            "volume_change_24h": packet.volume_change_24h,
            "timestamp": packet.timestamp,
            
            # Technical indicators
            "rsi": packet.technical_indicators.rsi_14,
            "rsi_21": packet.technical_indicators.rsi_21,
            "macd": packet.technical_indicators.macd_line,
            "macd_signal": packet.technical_indicators.macd_signal,
            "macd_histogram": packet.technical_indicators.macd_histogram,
            "bb_upper": packet.technical_indicators.bb_upper,
            "bb_middle": packet.technical_indicators.bb_middle,
            "bb_lower": packet.technical_indicators.bb_lower,
            "bb_position": packet.technical_indicators.bb_position,
            "atr": packet.technical_indicators.atr_14,
            "stoch_k": packet.technical_indicators.stoch_k,
            "volume_ratio": packet.technical_indicators.volume_ratio,
            
            # Sentiment and on-chain
            "fear_greed": packet.market_sentiment.fear_greed_index,
            "fear_greed_class": packet.market_sentiment.fear_greed_classification,
            "network_health": packet.onchain_metrics.network_health_score,
            "whale_activity": packet.onchain_metrics.whale_activity_score,
            "mvrv": packet.onchain_metrics.mvrv_ratio,
            "nvt": packet.onchain_metrics.nvt_ratio,
            
            # Derived metrics
            "volatility": packet.volatility,
            "trend_strength": packet.trend_strength,
            "entropy_level": packet.entropy_level,
            "liquidity_score": packet.liquidity_score,
            "momentum_score": packet.momentum_score,
            
            # Quality metrics
            "data_quality": packet.data_quality.value,
            "source_count": packet.source_count,
            "freshness_score": packet.freshness_score
        }
    
    def _calculate_enhanced_trading_signals(self, packet: Optional[MarketDataPacket], data: Dict[str, Any]) -> Dict[str, Any]:
        """Calculate enhanced trading signals using unified market data."""
        signals = {
            "buy_signals": [],
            "sell_signals": [],
            "neutral_signals": [],
            "signal_strength": 0.0,
            "confidence": 0.0
        }
        
        if not packet:
            return signals
        
        ti = packet.technical_indicators
        sentiment = packet.market_sentiment
        onchain = packet.onchain_metrics
        
        # RSI signals
        if ti.rsi_14 < 30:
            signals["buy_signals"].append({"indicator": "rsi_oversold", "strength": 0.8, "value": ti.rsi_14})
        elif ti.rsi_14 > 70:
            signals["sell_signals"].append({"indicator": "rsi_overbought", "strength": 0.8, "value": ti.rsi_14})
        
        # MACD signals
        if ti.macd_histogram > 0 and ti.macd_line > ti.macd_signal:
            signals["buy_signals"].append({"indicator": "macd_bullish", "strength": 0.7, "value": ti.macd_histogram})
        elif ti.macd_histogram < 0 and ti.macd_line < ti.macd_signal:
            signals["sell_signals"].append({"indicator": "macd_bearish", "strength": 0.7, "value": ti.macd_histogram})
        
        # Bollinger Bands signals
        if ti.bb_position < 0.1:
            signals["buy_signals"].append({"indicator": "bb_oversold", "strength": 0.6, "value": ti.bb_position})
        elif ti.bb_position > 0.9:
            signals["sell_signals"].append({"indicator": "bb_overbought", "strength": 0.6, "value": ti.bb_position})
        
        # Volume signals
        if ti.volume_ratio > 2.0:
            signals["buy_signals"].append({"indicator": "volume_surge", "strength": 0.5, "value": ti.volume_ratio})
        
        # Fear & Greed signals
        if sentiment.fear_greed_index < 25:
            signals["buy_signals"].append({"indicator": "extreme_fear", "strength": 0.4, "value": sentiment.fear_greed_index})
        elif sentiment.fear_greed_index > 75:
            signals["sell_signals"].append({"indicator": "extreme_greed", "strength": 0.4, "value": sentiment.fear_greed_index})
        
        # On-chain signals
        if onchain.mvrv_ratio < 0.8:
            signals["buy_signals"].append({"indicator": "mvrv_undervalued", "strength": 0.3, "value": onchain.mvrv_ratio})
        elif onchain.mvrv_ratio > 3.0:
            signals["sell_signals"].append({"indicator": "mvrv_overvalued", "strength": 0.3, "value": onchain.mvrv_ratio})
        
        # Network health signals
        if onchain.network_health_score > 80:
            signals["buy_signals"].append({"indicator": "network_healthy", "strength": 0.2, "value": onchain.network_health_score})
        elif onchain.network_health_score < 30:
            signals["sell_signals"].append({"indicator": "network_unhealthy", "strength": 0.2, "value": onchain.network_health_score})
        
        # Calculate overall signal strength
        buy_strength = sum(s["strength"] for s in signals["buy_signals"])
        sell_strength = sum(s["strength"] for s in signals["sell_signals"])
        
        signals["signal_strength"] = buy_strength - sell_strength
        signals["confidence"] = min(1.0, (buy_strength + sell_strength) / 5.0)
        
        # Data quality affects confidence
        quality_multiplier = {
            "excellent": 1.0,
            "good": 0.9,
            "acceptable": 0.7,
            "poor": 0.5,
            "failed": 0.1
        }.get(packet.data_quality.value, 0.5)
        
        signals["confidence"] *= quality_multiplier
        
        return signals
    
    def _assess_risk_with_market_data(self, packet: Optional[MarketDataPacket], signals: Dict[str, Any]) -> Dict[str, Any]:
        """Assess trading risk using market data and portfolio state."""
        risk_assessment = {
            "risk_level": "medium",
            "risk_score": 0.5,
            "volatility_risk": 0.5,
            "liquidity_risk": 0.5,
            "data_quality_risk": 0.5,
            "position_risk": 0.5,
            "recommended_position_size": 0.1,
            "stop_loss_distance": 0.02,
            "take_profit_distance": 0.04
        }
        
        if not packet:
            risk_assessment["risk_level"] = "high"
            risk_assessment["risk_score"] = 0.8
            return risk_assessment
        
        # Volatility risk assessment
        volatility_risk = min(1.0, packet.volatility * 2.0)
        risk_assessment["volatility_risk"] = volatility_risk
        
        # Liquidity risk assessment
        liquidity_risk = 1.0 - packet.liquidity_score
        risk_assessment["liquidity_risk"] = liquidity_risk
        
        # Data quality risk
        quality_risk = 1.0 - packet.metadata.get("quality_score", 0.5)
        risk_assessment["data_quality_risk"] = quality_risk
        
        # Calculate overall risk score
        risk_score = (volatility_risk + liquidity_risk + quality_risk) / 3.0
        risk_assessment["risk_score"] = risk_score
        
        # Risk level classification
        if risk_score < 0.3:
            risk_assessment["risk_level"] = "low"
        elif risk_score < 0.6:
            risk_assessment["risk_level"] = "medium"
        else:
            risk_assessment["risk_level"] = "high"
        
        # Position sizing based on risk
        base_position_size = 0.1
        risk_multiplier = 1.0 - (risk_score * 0.8)  # Reduce size for higher risk
        confidence_multiplier = signals.get("confidence", 0.5)
        
        recommended_size = base_position_size * risk_multiplier * confidence_multiplier
        risk_assessment["recommended_position_size"] = max(0.01, min(0.25, recommended_size))
        
        # Dynamic stop loss based on ATR and volatility
        atr_distance = packet.technical_indicators.atr_14 / packet.price if packet.price > 0 else 0.02
        volatility_distance = packet.volatility * 2.0
        
        stop_loss_distance = max(0.01, min(0.05, (atr_distance + volatility_distance) / 2.0))
        risk_assessment["stop_loss_distance"] = stop_loss_distance
        
        # Take profit target (risk-reward ratio of 2:1)
        risk_assessment["take_profit_distance"] = stop_loss_distance * 2.0
        
        return risk_assessment
    
    def _determine_trade_action(self, signals: Dict[str, Any], risk_assessment: Dict[str, Any]) -> Dict[str, Any]:
        """Determine trade action based on signals and risk assessment."""
        signal_strength = signals.get("signal_strength", 0.0)
        confidence = signals.get("confidence", 0.0)
        risk_level = risk_assessment.get("risk_level", "high")
        
        # Minimum confidence thresholds based on risk
        min_confidence = {
            "low": 0.3,
            "medium": 0.5,
            "high": 0.7
        }.get(risk_level, 0.7)
        
        action = "hold"
        reason = "Insufficient signal strength or confidence"
        
        if confidence >= min_confidence:
            if signal_strength > 0.5:
                action = "buy"
                reason = f"Strong buy signals (strength: {signal_strength:.2f}, confidence: {confidence:.2f})"
            elif signal_strength < -0.5:
                action = "sell"
                reason = f"Strong sell signals (strength: {signal_strength:.2f}, confidence: {confidence:.2f})"
        
        return {
            "action": action,
            "reason": reason,
            "signal_strength": signal_strength,
            "confidence": confidence,
            "position_size": risk_assessment.get("recommended_position_size", 0.1),
            "stop_loss_distance": risk_assessment.get("stop_loss_distance", 0.02),
            "take_profit_distance": risk_assessment.get("take_profit_distance", 0.04)
        }
    
    async def _execute_trade_with_market_data(
        self, 
        trade_action: Dict[str, Any], 
        packet: Optional[MarketDataPacket], 
        data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Execute trade with enhanced market data context."""
        try:
            current_price = packet.price if packet else data.get("price", 0.0)
            action = trade_action["action"]
            position_size = trade_action["position_size"]
            
            # Calculate trade parameters
            if action == "buy":
                entry_price = current_price
                stop_loss = entry_price * (1 - trade_action["stop_loss_distance"])
                take_profit = entry_price * (1 + trade_action["take_profit_distance"])
                trade_amount = self.state.current_capital * position_size
                
            elif action == "sell":
                entry_price = current_price
                stop_loss = entry_price * (1 + trade_action["stop_loss_distance"])
                take_profit = entry_price * (1 - trade_action["take_profit_distance"])
                # Use available capital for sell amount calculation
                trade_amount = self.state.current_capital * position_size * 0.5  # Max 50% of capital
            else:
                return {"error": "Invalid trade action"}
            
            # Simulate trade execution (replace with actual exchange API)
            trade_result = {
                "trade_id": f"{int(time.time())}_{action}_{self.symbol}",
                "timestamp": time.time(),
                "symbol": self.symbol,
                "action": action,
                "entry_price": entry_price,
                "amount": trade_amount,
                "stop_loss": stop_loss,
                "take_profit": take_profit,
                "position_size_pct": position_size,
                "status": "executed",
                "fees": trade_amount * 0.001,  # 0.1% fee
                "market_context": {
                    "rsi": data.get("rsi", 50),
                    "volatility": data.get("volatility", 0.5),
                    "data_quality": data.get("data_quality", "unknown"),
                    "signal_strength": trade_action["signal_strength"],
                    "confidence": trade_action["confidence"]
                }
            }
            
            # Update pipeline capital directly
            if action == "buy":
                self.state.current_capital -= (trade_amount + trade_result["fees"])
            elif action == "sell":
                self.state.current_capital += (trade_amount - trade_result["fees"])
            
            logger.info(f"Trade executed: {action} {trade_amount:.2f} {self.symbol} at ${entry_price:.2f}")
            
            return trade_result
            
        except Exception as e:
            logger.error(f"Error executing trade: {e}")
            return {"error": str(e)}
    
    def _log_trade_to_registry(
        self, 
        packet: MarketDataPacket, 
        trade_action: Dict[str, Any], 
        trade_result: Dict[str, Any]
    ):
        """Log trade to soulprint registry with market data context."""
        if not self.registry:
            return
        
        try:
            # Create comprehensive schwafit info
            schwafit_info = {
                "symbol": packet.symbol,
                "price": packet.price,
                "rsi_14": packet.technical_indicators.rsi_14,
                "macd_line": packet.technical_indicators.macd_line,
                "bb_position": packet.technical_indicators.bb_position,
                "volatility": packet.volatility,
                "trend_strength": packet.trend_strength,
                "entropy_level": packet.entropy_level,
                "momentum_score": packet.momentum_score,
                "fear_greed": packet.market_sentiment.fear_greed_index,
                "network_health": packet.onchain_metrics.network_health_score,
                "whale_activity": packet.onchain_metrics.whale_activity_score,
                "mvrv": packet.onchain_metrics.mvrv_ratio,
                "data_quality": packet.data_quality.value,
                "source_count": packet.source_count,
                "signal_strength": trade_action["signal_strength"],
                "confidence": trade_action["confidence"],
                "action": trade_action["action"]
            }
            
            # Log to registry
            self.registry.log_trigger(
                asset=packet.symbol,
                phase=packet.technical_indicators.bb_position,
                drift=packet.momentum_score,
                schwafit_info=schwafit_info,
                trade_result=trade_result
            )
            
            logger.info(f"Trade logged to registry: {trade_action['action']} {packet.symbol}")
            
        except Exception as e:
            logger.error(f"Failed to log trade to registry: {e}")

    def _enhance_market_data_with_crlf(self, market_data: MarketData) -> CRLFEnhancedMarketData:
        """
        Enhance market data with CRLF analysis.
        
        Args:
            market_data: Base market data
            
        Returns:
            Enhanced market data with CRLF analysis
        """
        # Prepare strategy vector from market data
        strategy_vector = np.array([
            market_data.volatility,      # Momentum component
            market_data.trend_strength,  # Scalping component
            1.0 - market_data.volatility,  # Mean reversion component
            market_data.entropy_level / 10.0  # Swing component (normalized)
        ])
        
        # Prepare profit curve from market data history
        if len(self.market_data_history) >= 7:
            profit_curve = np.array([
                md.price for md in self.market_data_history[-7:]
            ])
        else:
            # Use current price repeated if not enough history
            profit_curve = np.array([market_data.price] * 7)
        
        # Compute CRLF
        crlf_response = self.crlf.compute_crlf(
            strategy_vector=strategy_vector,
            profit_curve=profit_curve,
            market_entropy=market_data.entropy_level / 10.0,
            time_offset=0.0
        )
        
        # Calculate strategy alignment score
        strategy_alignment = self._compute_strategy_alignment_score(crlf_response)
        
        # Calculate temporal resonance
        temporal_resonance = self._compute_temporal_resonance(crlf_response)
        
        return CRLFEnhancedMarketData(
            base_market_data=market_data,
            crlf_response=crlf_response,
            strategy_alignment_score=strategy_alignment,
            temporal_resonance=temporal_resonance,
            recursion_depth=crlf_response.recursion_depth,
            trigger_state=crlf_response.trigger_state
        )

    def _enhance_market_data_with_zpe_zbe(self, market_data: MarketData) -> ZPEZBEMarketData:
        """
        Enhance market data with ZPE-ZBE analysis.
        
        Args:
            market_data: Base market data
            
        Returns:
            Enhanced market data with ZPE-ZBE analysis
        """
        # Prepare market data for quantum analysis
        quantum_market_data = {
            'price': market_data.price,
            'entry_price': market_data.price,  # Could be enhanced with actual entry price
            'lower_bound': market_data.price * 0.95,
            'upper_bound': market_data.price * 1.05,
            'frequency': 7.83,  # Earth's Schumann resonance
            'mass_coefficient': 1e-6
        }
        
        # Perform quantum market analysis
        quantum_analysis = self.unified_math_system.quantum_market_analysis(quantum_market_data)
        
        # Calculate ZPE vector
        zpe_vector = self.zpe_zbe_core.calculate_zero_point_energy(
            frequency=quantum_market_data['frequency'],
            mass_coefficient=quantum_market_data['mass_coefficient']
        )
        
        # Calculate ZBE balance
        zbe_balance = self.zpe_zbe_core.calculate_zbe_balance(
            entry_price=quantum_market_data['entry_price'],
            current_price=quantum_market_data['price'],
            lower_bound=quantum_market_data['lower_bound'],
            upper_bound=quantum_market_data['upper_bound']
        )
        
        return ZPEZBEMarketData(
            base_market_data=market_data,
            zpe_vector=zpe_vector,
            zbe_balance=zbe_balance,
            quantum_sync_status=zpe_vector.sync_status,
            quantum_potential=quantum_analysis['quantum_potential'],
            resonance_factor=quantum_analysis['resonance_factor'],
            strategy_confidence=quantum_analysis['strategy_confidence'],
            soulprint_vector=quantum_analysis['soulprint_vector']
        )

    def _enhance_strategy_selection_with_zpe_zbe(
        self, 
        market_data: MarketData, 
        regime: MarketRegime
    ) -> Tuple[StrategyBranch, Dict[str, Any]]:
        """
        Enhance strategy selection with ZPE-ZBE analysis.
        
        Args:
            market_data: Market data
            regime: Market regime
            
        Returns:
            Tuple of (strategy_branch, zpe_zbe_analysis)
        """
        # Get base strategy
        base_strategy = self._determine_optimal_strategy(regime, market_data)
        
        # Enhance with ZPE-ZBE analysis
        zpe_zbe_market_data = self._enhance_market_data_with_zpe_zbe(market_data)
        
        # Get quantum strategy recommendations
        quantum_recommendations = self.unified_math_system.get_quantum_strategy_recommendations()
        
        # Adjust strategy based on quantum analysis
        if zpe_zbe_market_data.quantum_sync_status in [
            QuantumSyncStatus.FULL_SYNC, QuantumSyncStatus.RESONANCE
        ]:
            # High quantum sync - use more conservative strategy
            if base_strategy == StrategyBranch.MOMENTUM:
                adjusted_strategy = StrategyBranch.SWING
            elif base_strategy == StrategyBranch.SCALPING:
                adjusted_strategy = StrategyBranch.MEAN_REVERSION
            else:
                adjusted_strategy = base_strategy
        else:
            # Low quantum sync - use more aggressive strategy
            if base_strategy == StrategyBranch.SWING:
                adjusted_strategy = StrategyBranch.MOMENTUM
            elif base_strategy == StrategyBranch.MEAN_REVERSION:
                adjusted_strategy = StrategyBranch.SCALPING
            else:
                adjusted_strategy = base_strategy
        
        return adjusted_strategy, {
            'zpe_energy': zpe_zbe_market_data.zpe_vector.energy,
            'zbe_status': zpe_zbe_market_data.zbe_balance.status,
            'quantum_sync_status': zpe_zbe_market_data.quantum_sync_status.value,
            'quantum_potential': zpe_zbe_market_data.quantum_potential,
            'strategy_confidence': zpe_zbe_market_data.strategy_confidence,
            'recommendations': quantum_recommendations
        }

    def _enhance_trading_decision_with_zpe_zbe(
        self, 
        base_decision: TradingDecision, 
        zpe_zbe_market_data: ZPEZBEMarketData
    ) -> ZPEZBETradingDecision:
        """
        Enhance trading decision with ZPE-ZBE analysis.
        
        Args:
            base_decision: Base trading decision
            zpe_zbe_market_data: Enhanced market data with ZPE-ZBE analysis
            
        Returns:
            Enhanced trading decision with ZPE-ZBE analysis
        """
        # Get quantum decision routing
        quantum_analysis = {
            'is_synced': zpe_zbe_market_data.quantum_sync_status in [
                QuantumSyncStatus.FULL_SYNC, QuantumSyncStatus.RESONANCE
            ],
            'zpe_energy': zpe_zbe_market_data.zpe_vector.energy,
            'zbe_status': zpe_zbe_market_data.zbe_balance.status,
            'quantum_potential': zpe_zbe_market_data.quantum_potential,
            'strategy_confidence': zpe_zbe_market_data.strategy_confidence
        }
        
        quantum_decision = self.unified_math_system.advanced_quantum_decision_router(quantum_analysis)
        
        # Calculate system entropy
        system_entropy = self.unified_math_system.get_system_entropy(quantum_analysis)
        
        # Log performance for adaptive learning
        strategy_metadata = {
            'strategy_id': base_decision.strategy_branch.value,
            'profit': base_decision.profit_potential,
            'risk_score': base_decision.risk_score,
            'thermal_state': base_decision.thermal_state.value,
            'bit_phase': base_decision.bit_phase.value
        }
        
        self.unified_math_system.log_strategy_performance(
            zpe_zbe_market_data.zpe_vector,
            zpe_zbe_market_data.zbe_balance,
            strategy_metadata
        )
        
        return ZPEZBETradingDecision(
            base_decision=base_decision,
            zpe_energy=zpe_zbe_market_data.zpe_vector.energy,
            zbe_status=zpe_zbe_market_data.zbe_balance.status,
            quantum_sync_status=zpe_zbe_market_data.quantum_sync_status,
            quantum_potential=zpe_zbe_market_data.quantum_potential,
            strategy_confidence=zpe_zbe_market_data.strategy_confidence,
            recommended_action=quantum_decision['action'],
            risk_adjustment=quantum_decision['risk_adjustment'],
            system_entropy=system_entropy
        )

    def _enhance_risk_management_with_zpe_zbe(
        self, 
        signal: Dict[str, Any], 
        zpe_zbe_market_data: ZPEZBEMarketData
    ) -> Dict[str, Any]:
        """
        Enhance risk management with ZPE-ZBE analysis.
        
        Args:
            signal: Trading signal
            zpe_zbe_market_data: Enhanced market data with ZPE-ZBE analysis
            
        Returns:
            Enhanced signal with ZPE-ZBE risk adjustments
        """
        # Get base risk parameters
        enhanced_signal = signal.copy()
        
        # Adjust risk based on quantum sync status
        if zpe_zbe_market_data.quantum_sync_status == QuantumSyncStatus.RESONANCE:
            # High quantum sync - reduce risk
            enhanced_signal['risk_multiplier'] = 0.5
            enhanced_signal['position_size_multiplier'] = 1.5
        elif zpe_zbe_market_data.quantum_sync_status == QuantumSyncStatus.FULL_SYNC:
            # Good quantum sync - moderate risk
            enhanced_signal['risk_multiplier'] = 0.8
            enhanced_signal['position_size_multiplier'] = 1.2
        elif zpe_zbe_market_data.quantum_sync_status == QuantumSyncStatus.PARTIAL_SYNC:
            # Partial quantum sync - normal risk
            enhanced_signal['risk_multiplier'] = 1.0
            enhanced_signal['position_size_multiplier'] = 1.0
        else:
            # No quantum sync - increase risk
            enhanced_signal['risk_multiplier'] = 1.5
            enhanced_signal['position_size_multiplier'] = 0.8
        
        # Adjust based on ZBE status
        if abs(zpe_zbe_market_data.zbe_balance.status) > 0.5:
            # Far from equilibrium - reduce position size
            enhanced_signal['position_size_multiplier'] *= 0.7
        
        # Adjust based on strategy confidence
        if zpe_zbe_market_data.strategy_confidence > 0.8:
            enhanced_signal['confidence_multiplier'] = 1.2
        elif zpe_zbe_market_data.strategy_confidence < 0.4:
            enhanced_signal['confidence_multiplier'] = 0.6
        else:
            enhanced_signal['confidence_multiplier'] = 1.0
        
        return enhanced_signal

    def _update_zpe_zbe_performance_metrics(self, zpe_zbe_decision: ZPEZBETradingDecision) -> None:
        """
        Update ZPE-ZBE performance metrics.
        
        Args:
            zpe_zbe_decision: Enhanced trading decision with ZPE-ZBE analysis
        """
        # Update ZPE-ZBE state
        self.zpe_zbe_state.current_zpe_energy = zpe_zbe_decision.zpe_energy
        self.zpe_zbe_state.current_zbe_status = zpe_zbe_decision.zbe_status
        self.zpe_zbe_state.quantum_sync_status = zpe_zbe_decision.quantum_sync_status
        self.zpe_zbe_state.quantum_potential = zpe_zbe_decision.quantum_potential
        self.zpe_zbe_state.system_entropy = zpe_zbe_decision.system_entropy
        
        # Store last analysis
        self.zpe_zbe_state.last_zpe_analysis = {
            'energy': zpe_zbe_decision.zpe_energy,
            'sync_status': zpe_zbe_decision.quantum_sync_status.value,
            'potential': zpe_zbe_decision.quantum_potential
        }
        
        self.zpe_zbe_state.last_zbe_analysis = {
            'status': zpe_zbe_decision.zbe_status,
            'stability_score': zpe_zbe_decision.base_decision.metadata.get('zbe_stability_score', 0.0)
        }


    def _enhance_trading_decision_with_crlf(
        self, 
        base_decision: TradingDecision, 
        crlf_market_data: CRLFEnhancedMarketData
    ) -> CRLFEnhancedTradingDecision:
        """
        Enhance trading decision with CRLF analysis.
        
        Args:
            base_decision: Base trading decision
            crlf_market_data: Enhanced market data with CRLF analysis
            
        Returns:
            Enhanced trading decision with CRLF analysis
        """
        crlf_response = crlf_market_data.crlf_response
        
        # Adjust decision based on CRLF trigger state
        adjusted_decision = self._adjust_decision_with_crlf(base_decision, crlf_response)
        
        # Update CRLF state
        self._update_crlf_pipeline_state(crlf_response)
        
        return CRLFEnhancedTradingDecision(
            base_decision=adjusted_decision,
            crlf_output=crlf_response.crlf_output,
            trigger_state=crlf_response.trigger_state,
            strategy_alignment=crlf_market_data.strategy_alignment_score,
            temporal_urgency=crlf_response.recommendations.get('temporal_urgency', 'MEDIUM'),
            recursion_depth=crlf_response.recursion_depth,
            risk_adjustment=crlf_response.recommendations.get('risk_adjustment', 1.0),
            strategy_weights=crlf_response.recommendations.get('strategy_weights', {})
        )

    def _adjust_decision_with_crlf(
        self, 
        base_decision: TradingDecision, 
        crlf_response: CRLFResponse
    ) -> TradingDecision:
        """
        Adjust trading decision based on CRLF analysis.
        
        Args:
            base_decision: Base trading decision
            crlf_response: CRLF response
            
        Returns:
            Adjusted trading decision
        """
        adjusted_decision = base_decision
        
        # Adjust based on trigger state
        if crlf_response.trigger_state == CRLFTriggerState.OVERRIDE:
            # Override - increase position size and confidence
            adjusted_decision.quantity *= 1.5
            adjusted_decision.confidence = min(1.0, adjusted_decision.confidence * 1.2)
            adjusted_decision.metadata['crlf_override'] = True
            adjusted_decision.metadata['override_matrix'] = "FastProfitOverrideÎ©"
            
        elif crlf_response.trigger_state == CRLFTriggerState.ESCALATE:
            # Escalate - moderate increase
            adjusted_decision.quantity *= 1.2
            adjusted_decision.confidence = min(1.0, adjusted_decision.confidence * 1.1)
            adjusted_decision.metadata['crlf_escalate'] = True
            
        elif crlf_response.trigger_state == CRLFTriggerState.HOLD:
            # Hold - reduce position size
            adjusted_decision.quantity *= 0.7
            adjusted_decision.confidence *= 0.9
            adjusted_decision.metadata['crlf_hold'] = True
            adjusted_decision.metadata['hold_duration'] = crlf_response.recommendations.get('hold_duration', 300)
            
        elif crlf_response.trigger_state == CRLFTriggerState.RECURSIVE_RESET:
            # Reset - use fallback strategy
            adjusted_decision.quantity *= 0.5
            adjusted_decision.confidence *= 0.7
            adjusted_decision.metadata['crlf_reset'] = True
            adjusted_decision.metadata['fallback_strategy'] = "Conservative_Mean_Reversion"
        
        # Apply risk adjustment
        risk_adjustment = crlf_response.recommendations.get('risk_adjustment', 1.0)
        adjusted_decision.risk_score *= risk_adjustment
        
        # Add CRLF metadata
        adjusted_decision.metadata.update({
            'crlf_output': crlf_response.crlf_output,
            'crlf_confidence': crlf_response.confidence,
            'recursion_depth': crlf_response.recursion_depth,
            'strategy_weights': crlf_response.recommendations.get('strategy_weights', {})
        })
        
        return adjusted_decision

    def _update_crlf_pipeline_state(self, crlf_response: CRLFResponse):
        """
        Update CRLF pipeline state with latest response.
        
        Args:
            crlf_response: Latest CRLF response
        """
        # Update current state
        self.crlf_enhanced_state.current_crlf_output = crlf_response.crlf_output
        self.crlf_enhanced_state.current_trigger_state = crlf_response.trigger_state
        
        # Update history
        self.crlf_enhanced_state.strategy_alignment_trend.append(
            self._compute_strategy_alignment_score(crlf_response)
        )
        self.crlf_enhanced_state.temporal_resonance_history.append(
            self._compute_temporal_resonance(crlf_response)
        )
        self.crlf_enhanced_state.recursion_depth_history.append(
            crlf_response.recursion_depth
        )
        
        # Keep history manageable
        max_history = 100
        if len(self.crlf_enhanced_state.strategy_alignment_trend) > max_history:
            self.crlf_enhanced_state.strategy_alignment_trend = self.crlf_enhanced_state.strategy_alignment_trend[-max_history:]
            self.crlf_enhanced_state.temporal_resonance_history = self.crlf_enhanced_state.temporal_resonance_history[-max_history:]
            self.crlf_enhanced_state.recursion_depth_history = self.crlf_enhanced_state.recursion_depth_history[-max_history:]
        
        # Store last analysis
        self.crlf_enhanced_state.last_crlf_analysis = {
            'crlf_output': crlf_response.crlf_output,
            'trigger_state': crlf_response.trigger_state.value,
            'confidence': crlf_response.confidence,
            'recursion_depth': crlf_response.recursion_depth,
            'recommendations': crlf_response.recommendations
        }

    def _compute_strategy_alignment_score(self, crlf_response: CRLFResponse) -> float:
        """
        Compute strategy alignment score from CRLF response.
        
        Args:
            crlf_response: CRLF response
            
        Returns:
            Strategy alignment score (0.0 to 1.0)
        """
        # Higher confidence and lower entropy = better alignment
        alignment = crlf_response.confidence * (1.0 - crlf_response.entropy_updated)
        return np.clip(alignment, 0.0, 1.0)
    
    def _compute_temporal_resonance(self, crlf_response: CRLFResponse) -> float:
        """
        Compute temporal resonance from CRLF response.
        
        Args:
            crlf_response: CRLF response
            
        Returns:
            Temporal resonance score (0.0 to 1.0)
        """
        # Temporal resonance based on CRLF output magnitude and confidence
        resonance = abs(crlf_response.crlf_output) * crlf_response.confidence
        return np.clip(resonance, 0.0, 1.0)
    
    def get_crlf_performance_summary(self) -> Dict[str, Any]:
        """
        Get CRLF performance summary.
        
        Returns:
            CRLF performance summary
        """
        crlf_summary = self.crlf.get_performance_summary()
        
        return {
            'crlf_performance': crlf_summary,
            'pipeline_crlf_state': {
                'current_crlf_output': self.crlf_enhanced_state.current_crlf_output,
                'current_trigger_state': self.crlf_enhanced_state.current_trigger_state.value,
                'strategy_alignment_trend': self.crlf_enhanced_state.strategy_alignment_trend[-10:] if self.crlf_enhanced_state.strategy_alignment_trend else [],
                'temporal_resonance_history': self.crlf_enhanced_state.temporal_resonance_history[-10:] if self.crlf_enhanced_state.temporal_resonance_history else [],
                'recursion_depth_history': self.crlf_enhanced_state.recursion_depth_history[-10:] if self.crlf_enhanced_state.recursion_depth_history else [],
                'last_crlf_analysis': self.crlf_enhanced_state.last_crlf_analysis
            }
        }

    def get_zpe_zbe_pipeline_summary(self) -> Dict[str, Any]:
        """
        Get ZPE-ZBE enhanced pipeline summary.
        
        Returns:
            Enhanced pipeline summary with ZPE-ZBE metrics
        """
        base_summary = self.get_pipeline_summary()
        
        # Get performance analysis
        performance_analysis = self.unified_math_system.get_performance_analysis()
        quantum_recommendations = self.unified_math_system.get_quantum_strategy_recommendations()
        
        return {
            **base_summary,
            'zpe_zbe_metrics': {
                'current_zpe_energy': self.zpe_zbe_state.current_zpe_energy,
                'current_zbe_status': self.zpe_zbe_state.current_zbe_status,
                'quantum_sync_status': self.zpe_zbe_state.quantum_sync_status.value,
                'quantum_potential': self.zpe_zbe_state.quantum_potential,
                'system_entropy': self.zpe_zbe_state.system_entropy,
                'last_zpe_analysis': self.zpe_zbe_state.last_zpe_analysis,
                'last_zbe_analysis': self.zpe_zbe_state.last_zbe_analysis
            },
            'quantum_performance': performance_analysis,
            'quantum_recommendations': quantum_recommendations
        }

    def _analyze_market_regime(self, market_data: MarketData) -> MarketRegime:
        """Analyze current market regime using mathematical indicators and quantum insights."""
        if len(self.market_data_history) < 20:
            return MarketRegime.SIDEWAYS

        # Prepare market data for quantum analysis
        quantum_market_data = {
            'price': market_data.price,
            'volume': market_data.volume,
            'volatility': market_data.volatility,
            'entry_price': self.market_data_history[0].price if self.market_data_history else market_data.price,
            'frequency': 7.83,  # Earth's Schumann resonance frequency
            'mass_coefficient': market_data.volume / 1000000.0  # Normalize volume
        }

        # Perform quantum market analysis
        quantum_analysis = self.unified_math_system.quantum_market_analysis(quantum_market_data)

        # Get recent price data
        recent_prices = [md.price for md in self.market_data_history[-20:]]
        trend_slope = np.polyfit(range(len(recent_prices)), recent_prices, 1)[0]
        price_std = np.std(recent_prices)

        # Volatility analysis
        volatility = market_data.volatility
        high_vol_threshold = self.risk_params.volatility_threshold

        # Quantum-enhanced regime classification
        if quantum_analysis.get('is_synced', False):
            # During quantum sync, treat market as stable
            return MarketRegime.CALM
        
        # Traditional regime logic with quantum insights
        if volatility > high_vol_threshold:
            return MarketRegime.VOLATILE
        elif abs(trend_slope) < price_std * 0.1:
            return MarketRegime.SIDEWAYS
        elif trend_slope > 0:
            return MarketRegime.TRENDING_UP
        elif trend_slope < 0:
            return MarketRegime.TRENDING_DOWN
        else:
            return MarketRegime.CALM

    def _determine_optimal_strategy(
        self, regime: MarketRegime, market_data: MarketData
    ) -> StrategyBranch:
        """Determine optimal strategy based on market regime."""
        strategy_map = {
            MarketRegime.TRENDING_UP: StrategyBranch.MOMENTUM,
            MarketRegime.TRENDING_DOWN: StrategyBranch.MOMENTUM,
            MarketRegime.SIDEWAYS: StrategyBranch.MEAN_REVERSION,
            MarketRegime.VOLATILE: StrategyBranch.SCALPING,
            MarketRegime.CALM: StrategyBranch.GRID,
        }

        base_strategy = strategy_map.get(regime, StrategyBranch.MOMENTUM)

        # Strategy refinement based on additional factors
        if market_data.volume > 1.5 * np.mean([md.volume for md in self.market_data_history[-10:]]):
            # High volume - prefer momentum or arbitrage
            if regime in [MarketRegime.TRENDING_UP, MarketRegime.TRENDING_DOWN]:
                return StrategyBranch.MOMENTUM
            else:
                return StrategyBranch.ARBITRAGE

        return base_strategy

    def _update_thermal_state(self, market_data: MarketData):
        """Update thermal state based on market conditions and quantum synchronization."""
        # Prepare market data for quantum analysis
        quantum_market_data = {
            'price': market_data.price,
            'volume': market_data.volume,
            'volatility': market_data.volatility,
            'entry_price': self.market_data_history[0].price if self.market_data_history else market_data.price,
            'frequency': 7.83,  # Earth's Schumann resonance frequency
            'mass_coefficient': market_data.volume / 1000000.0  # Normalize volume
        }

        # Perform quantum market analysis
        quantum_analysis = self.unified_math_system.quantum_market_analysis(quantum_market_data)

        # Thermal state logic based on entropy and volatility
        entropy = market_data.entropy_level
        volatility = market_data.volatility
        quantum_potential = quantum_analysis.get('quantum_potential', 0.0)

        # Quantum synchronization impacts thermal state
        if quantum_analysis.get('is_synced', False):
            # Quantum sync leads to a stable, cool state
            self.state.thermal_state = ThermalState.COOL
            self.state.bit_phase = BitPhase.EIGHT_BIT
        elif entropy > 6.0 or volatility > 0.8 or quantum_potential > 0.7:
            # High entropy, volatility, or quantum potential leads to hot state
            self.state.thermal_state = ThermalState.HOT
            self.state.bit_phase = BitPhase.THIRTY_TWO_BIT
        elif entropy > 4.0 or volatility > 0.5 or quantum_potential > 0.3:
            # Moderate conditions lead to warm state
            self.state.thermal_state = ThermalState.WARM
            self.state.bit_phase = BitPhase.SIXTEEN_BIT
        else:
            # Low entropy and volatility lead to cool state
            self.state.thermal_state = ThermalState.COOL
            self.state.bit_phase = BitPhase.EIGHT_BIT

    async def _generate_signal(
        self, market_data: MarketData, strategy: StrategyBranch
    ) -> Optional[Dict[str, Any]]:
        """Generate trading signal based on strategy."""
        signal_generators = {
            StrategyBranch.MOMENTUM: self._momentum_signal,
            StrategyBranch.MEAN_REVERSION: self._mean_reversion_signal,
            StrategyBranch.ARBITRAGE: self._arbitrage_signal,
            StrategyBranch.SCALPING: self._scalping_signal,
            StrategyBranch.SWING: self._swing_signal,
            StrategyBranch.GRID: self._grid_signal,
        }

        generator = signal_generators.get(strategy)
        if not generator:
            return None

        return generator(market_data)

    def _select_vectorization_mode(
        self, strategy: StrategyBranch, market_data: MarketData
    ) -> VectorizationMode:
        """Select appropriate vectorization mode."""
        if strategy in [StrategyBranch.SCALPING, StrategyBranch.ARBITRAGE]:
            return VectorizationMode.HIGH_FREQUENCY
        elif strategy == StrategyBranch.MOMENTUM:
            return VectorizationMode.MOMENTUM_BASED
        elif strategy == StrategyBranch.MEAN_REVERSION:
            return VectorizationMode.MEAN_REVERSION
        else:
            return VectorizationMode.ADAPTIVE

    def _create_profit_vector(
        self, signal: Dict[str, Any], market_data: MarketData
    ) -> ProfitVector:
        """Create profit vector for the signal."""
        # This method needs to adapt to receive IntegratedTradingSignal or its data
        # For now, I'll adjust it to expect a dict compatible with previous signals.
        # If signal is IntegratedTradingSignal, convert it to dict for compatibility.
        if isinstance(signal, IntegratedTradingSignal):
            # Convert to a dictionary that _create_profit_vector can understand
            # Adjust keys to match what profit_vectorizer expects
            signal_dict = {
                "action": signal.recommended_action.upper(),
                "quantity": float(signal.quantity), # Use the actual quantity from IntegratedTradingSignal
                "confidence": float(signal.confidence_score),
                "profit_potential": float(signal.profit_potential),
                "risk_score": float(signal.risk_assessment.get("overall_risk", 0.5)),
            }
        else:
            signal_dict = signal

        mode = self._select_vectorization_mode(self.state.active_strategy, market_data)
        return self.profit_vectorizer.calculate_profit_vector(
            market_data.price,
            market_data.volume,
            signal_dict, # Pass the adjusted signal dict
            mode=mode,
        )

    def _mean_reversion_signal(self, market_data: MarketData) -> Dict[str, Any]:
        """Generate mean reversion signal."""
        if len(self.market_data_history) < 20:
            return None

        recent_prices = [md.price for md in self.market_data_history[-20:]]
        mean_price = np.mean(recent_prices)
        std_price = np.std(recent_prices)

        current_price = market_data.price
        z_score = (current_price - mean_price) / std_price if std_price > 0 else 0

        # Mean reversion logic
        if z_score > 2.0:  # Price too high
            return {
                "action": "SELL",
                "quantity": self._calculate_position_size(market_data, "SELL"),
                "confidence": min(abs(z_score) / 3.0, 1.0),
                "profit_potential": abs(z_score) * 0.01,
                "risk_score": 0.3,
                "metadata": {"z_score": z_score, "mean_price": mean_price},
            }
        elif z_score < -2.0:  # Price too low
            return {
                "action": "BUY",
                "quantity": self._calculate_position_size(market_data, "BUY"),
                "confidence": min(abs(z_score) / 3.0, 1.0),
                "profit_potential": abs(z_score) * 0.01,
                "risk_score": 0.3,
                "metadata": {"z_score": z_score, "mean_price": mean_price},
            }
        else:
            return None

    def _momentum_signal(self, market_data: MarketData) -> Dict[str, Any]:
        """Generate momentum signal."""
        if len(self.market_data_history) < 10:
            return None

        recent_prices = [md.price for md in self.market_data_history[-10:]]
        short_ma = np.mean(recent_prices[-5:])
        long_ma = np.mean(recent_prices)

        momentum = (short_ma - long_ma) / long_ma if long_ma > 0 else 0
        volume_surge = market_data.volume / np.mean(
            [md.volume for md in self.market_data_history[-5:]]
        )

        # Momentum logic
        if momentum > 0.01 and volume_surge > 1.2:  # Strong upward momentum
            return {
                "action": "BUY",
                "quantity": self._calculate_position_size(market_data, "BUY"),
                "confidence": min(momentum * 10, 1.0),
                "profit_potential": momentum * 2,
                "risk_score": 0.4,
                "metadata": {"momentum": momentum, "volume_surge": volume_surge},
            }
        elif momentum < -0.01 and volume_surge > 1.2:  # Strong downward momentum
            return {
                "action": "SELL",
                "quantity": self._calculate_position_size(market_data, "SELL"),
                "confidence": min(abs(momentum) * 10, 1.0),
                "profit_potential": abs(momentum) * 2,
                "risk_score": 0.4,
                "metadata": {"momentum": momentum, "volume_surge": volume_surge},
            }

        return None

    def _arbitrage_signal(self, market_data: MarketData) -> Dict[str, Any]:
        """Generate arbitrage signal."""
        # Simplified arbitrage logic (would need multiple exchanges in real implementation)
        if market_data.bid and market_data.ask:
            spread = (market_data.ask - market_data.bid) / market_data.price

            if spread > 0.005:  # Minimum profitable spread
                return {
                    "action": "BUY",  # Buy at bid, sell at ask
                    "quantity": self._calculate_position_size(market_data, "BUY") * 0.5,
                    "confidence": min(spread * 100, 1.0),
                    "profit_potential": spread,
                    "risk_score": 0.2,
                    "metadata": {"spread": spread, "bid": market_data.bid, "ask": market_data.ask},
                }

        return None

    def _scalping_signal(self, market_data: MarketData) -> Dict[str, Any]:
        """Generate scalping signal."""
        if len(self.market_data_history) < 5:
            return None

        # Very short-term price movement analysis
        recent_prices = [md.price for md in self.market_data_history[-5:]]
        price_change = (recent_prices[-1] - recent_prices[0]) / recent_prices[0]
        volatility = market_data.volatility

        # Scalping logic - capitalize on small movements
        if abs(price_change) > 0.002 and volatility > 0.3:
            action = "BUY" if price_change > 0 else "SELL"
            return {
                "action": action,
                # Higher frequency
                "quantity": self._calculate_position_size(market_data, action) * 2,
                "confidence": min(abs(price_change) * 100, 1.0),
                "profit_potential": abs(price_change) * 0.5,
                "risk_score": 0.6,
                "metadata": {"price_change": price_change, "volatility": volatility},
            }

        return None

    def _swing_signal(self, market_data: MarketData) -> Dict[str, Any]:
        """Generate swing trading signal."""
        if len(self.market_data_history) < 50:
            return None

        # Medium-term trend analysis
        prices = [md.price for md in self.market_data_history[-50:]]
        trend = np.polyfit(range(len(prices)), prices, 1)[0]
        current_price = market_data.price

        # Support and resistance levels
        recent_highs = [max(prices[i : i + 10]) for i in range(0, len(prices) - 10, 10)]
        recent_lows = [min(prices[i : i + 10]) for i in range(0, len(prices) - 10, 10)]

        resistance = np.mean(recent_highs) if recent_highs else current_price
        support = np.mean(recent_lows) if recent_lows else current_price

        # Swing logic
        if current_price <= support * 1.02 and trend > 0:  # Near support with uptrend
            return {
                "action": "BUY",
                "quantity": self._calculate_position_size(market_data, "BUY"),
                "confidence": 0.7,
                "profit_potential": (resistance - current_price) / current_price,
                "risk_score": 0.4,
                "metadata": {"support": support, "resistance": resistance, "trend": trend},
            }
        elif current_price >= resistance * 0.98 and trend < 0:  # Near resistance with downtrend
            return {
                "action": "SELL",
                "quantity": self._calculate_position_size(market_data, "SELL"),
                "confidence": 0.7,
                "profit_potential": (current_price - support) / current_price,
                "risk_score": 0.4,
                "metadata": {"support": support, "resistance": resistance, "trend": trend},
            }

        return None

    def _grid_signal(self, market_data: MarketData) -> Dict[str, Any]:
        """Generate grid trading signal."""
        if len(self.market_data_history) < 20:
            return None

        # Grid trading logic
        recent_prices = [md.price for md in self.market_data_history[-20:]]
        price_range = max(recent_prices) - min(recent_prices)
        grid_size = price_range / 10  # 10 grid levels

        current_price = market_data.price
        base_price = np.mean(recent_prices)

        # Determine grid position
        grid_level = round((current_price - base_price) / grid_size)

        # Grid logic - buy low, sell high within range
        if grid_level <= -2:  # Lower grid levels
            return {
                "action": "BUY",
                "quantity": self._calculate_position_size(market_data, "BUY") * 0.8,
                "confidence": 0.6,
                "profit_potential": 0.01,
                "risk_score": 0.3,
                "metadata": {"grid_level": grid_level, "grid_size": grid_size},
            }
        elif grid_level >= 2:  # Upper grid levels
            return {
                "action": "SELL",
                "quantity": self._calculate_position_size(market_data, "SELL") * 0.8,
                "confidence": 0.6,
                "profit_potential": 0.01,
                "risk_score": 0.3,
                "metadata": {"grid_level": grid_level, "grid_size": grid_size},
            }

        return None

    def _apply_risk_management(
        self, signal: Dict[str, Any], market_data: MarketData
    ) -> Optional[Dict[str, Any]]:
        # This method's logic will now be largely integrated into _determine_asset_and_signal
        # so it's kept as a placeholder or for very specific, final checks if needed.
        # For now, it simply returns the signal, as risk logic is shifting.
        return signal

    # --- New method to determine asset and formulate signal based on Ferris Wheel ---
    async def _determine_asset_and_signal(
        self, expanded_strategy_id: int, market_data: MarketData, current_strategy_branch: StrategyBranch
    ) -> Tuple[Optional[IntegratedTradingSignal], Optional[str]]:
        """
        Determines the asset to trade and formulates the trading signal
        based on the expanded strategy ID from the Ferris Wheel.

        This method integrates:
        - Ferris Wheel expansion logic
        - Dualistic state machine
        - Profit vectorization
        - Real-time portfolio data
        - Advanced mathematical decision making
        - Ghost Core interaction
        """
        try:
            # 1. PHASE BIT INTEGRATION - Determine optimal bit phase for this decision
            context_hash = f"{expanded_strategy_id}_{market_data.symbol}_{market_data.timestamp}"
            phase_resolution = self.phase_bit_integration.resolve_bit_phase(
                context_hash=context_hash,
                resolution_mode="auto"
            )

            logger.info(f"Phase resolution: {phase_resolution.bit_phase.value} bits, "
                       f"strategy: {phase_resolution.strategy_type.value}, "
                       f"confidence: {phase_resolution.confidence:.3f}")

            # 2. REAL ASSET SELECTION - Get available assets from portfolio
            portfolio_summary = self.portfolio_tracker.get_portfolio_summary()
            available_assets = []

            # Extract available trading pairs from portfolio
            if "positions" in portfolio_summary and portfolio_summary["positions"]:
                available_assets = list(portfolio_summary["positions"].keys())
            else:
                # Fallback to default tradable assets if portfolio is empty
                available_assets = [
                    "BTC/USDC", "ETH/USDC", "XRP/USDC",
                    "BTC/USDT", "ETH/USDT", "SOL/USDC"
                ]
                logger.info("Using default tradable assets (portfolio empty)")

            if not available_assets:
                logger.error("No tradable assets available")
                return None, None

            # 3. FERRIS WHEEL ASSET SELECTION - Use expanded strategy ID for deterministic selection
            asset_index = expanded_strategy_id % len(available_assets)
            selected_asset_symbol = available_assets[asset_index]

            # Convert to TradingPair enum if possible
            try:
                selected_trading_pair = TradingPair(selected_asset_symbol)
            except ValueError:
                # Create a custom TradingPair for unsupported symbols
                selected_trading_pair = TradingPair.BTC_USDC  # Default fallback
                logger.warning(f"Unsupported trading pair: {selected_asset_symbol}, using default")

            logger.info(f"Ferris Wheel selected: {selected_asset_symbol} (ID: {expanded_strategy_id}, "
                       f"Index: {asset_index}/{len(available_assets)})")

            # 4. DUALISTIC STATE ANALYSIS - Determine current market state and strategy alignment
            dualistic_state = self._analyze_dualistic_state(
                market_data, expanded_strategy_id, phase_resolution
            )

            # 5. PROFIT VECTORIZATION - Calculate expected profit vector for this asset/strategy
            profit_vector = await self._calculate_advanced_profit_vector(
                market_data, selected_asset_symbol, expanded_strategy_id,
                phase_resolution, dualistic_state
            )

            # 6. ADVANCED DECISION LOGIC - Integrate all mathematical components
            decision_data = self._integrate_decision_components(
                market_data, profit_vector, dualistic_state,
                expanded_strategy_id, phase_resolution
            )

            # 7. POSITION SIZING - Calculate optimal position size
            quantity = self._calculate_advanced_position_size(
                market_data, decision_data, profit_vector, dualistic_state
            )

            # 8. RISK ASSESSMENT - Comprehensive risk evaluation
            risk_assessment = self._calculate_comprehensive_risk(
                market_data, decision_data, profit_vector, quantity, dualistic_state
            )

            # 9. FINAL SIGNAL CONSTRUCTION - Create the complete trading signal
            if decision_data["action"] != "hold" and quantity > 0:
                signal = IntegratedTradingSignal(
                    signal_id=str(uuid.uuid4()),
                    recommended_action=decision_data["action"],
                    target_pair=selected_trading_pair,
                    quantity=Decimal(str(quantity)),
                    confidence_score=Decimal(str(decision_data["confidence"])),
                    profit_potential=Decimal(str(profit_vector.profit_score)),
                    risk_assessment={
                        "overall_risk": risk_assessment["overall_risk"],
                        "ferris_id": expanded_strategy_id,
                        "bit_phase": phase_resolution.bit_phase.value,
                        "dualistic_state": dualistic_state["state"],
                        "market_regime": market_data.metadata.get("market_regime", "unknown"),
                        "volatility_risk": risk_assessment["volatility_risk"],
                        "position_risk": risk_assessment["position_risk"],
                        "strategy_risk": risk_assessment["strategy_risk"]
                    },
                    ghost_route=f"ferris_wheel_{phase_resolution.strategy_type.value}",
                    timestamp=market_data.timestamp,
                )

                logger.info(f"Generated signal: {signal.recommended_action} {quantity} {selected_asset_symbol} "
                           f"(Confidence: {signal.confidence_score}, Profit: {signal.profit_potential})")

                return signal, selected_asset_symbol
            else:
                logger.info(f"No trade recommended for {selected_asset_symbol} "
                           f"(Action: {decision_data['action']}, Quantity: {quantity})")
                return None, selected_asset_symbol

        except Exception as e:
            logger.error(f"Error in _determine_asset_and_signal: {e}")
            return None, None

    def _analyze_dualistic_state(
        self, market_data: MarketData, expanded_strategy_id: int, phase_resolution: Any
    ) -> Dict[str, Any]:
        """
        Analyze dualistic state based on market data and strategy ID.
        This integrates your dualistic state machine logic.
        """
        # Create a hash-based dualistic state determination
        state_hash = hash(f"{expanded_strategy_id}_{market_data.price}_{market_data.volume}")

        # Determine state based on hash and market conditions
        if state_hash % 2 == 0:
            state = "positive_phase"
            confidence_multiplier = 1.2
        else:
            state = "negative_phase"
            confidence_multiplier = 0.8

        # Adjust based on market conditions
        if market_data.trend_strength > 0.7:
            state += "_trending"
        elif market_data.volatility > 0.8:
            state += "_volatile"

        return {
            "state": state,
            "confidence_multiplier": confidence_multiplier,
            "hash_value": state_hash,
            "bit_phase": phase_resolution.bit_phase.value,
            "market_alignment": market_data.trend_strength
        }

    async def _calculate_advanced_profit_vector(
        self, market_data: MarketData, asset_symbol: str,
        expanded_strategy_id: int, phase_resolution: Any, dualistic_state: Dict[str, Any]
    ) -> ProfitVector:
        """
        Calculate advanced profit vector using your profit vectorization system.
        """
        # Create comprehensive input for profit vectorization
        vector_input = {
            "price": market_data.price,
            "volume": market_data.volume,
            "volatility": market_data.volatility,
            "trend_strength": market_data.trend_strength,
            "entropy_level": market_data.entropy_level,
            "asset_symbol": asset_symbol,
            "strategy_id": expanded_strategy_id,
            "bit_phase": phase_resolution.bit_phase.value,
            "dualistic_state": dualistic_state["state"],
            "confidence_multiplier": dualistic_state["confidence_multiplier"],
            "timestamp": market_data.timestamp,
            "metadata": market_data.metadata
        }

        # Select vectorization mode based on strategy and market conditions
        if market_data.volatility > 0.8:
            mode = VectorizationMode.HIGH_FREQUENCY
        elif market_data.trend_strength > 0.7:
            mode = VectorizationMode.MOMENTUM_BASED
        elif market_data.trend_strength < 0.3:
            mode = VectorizationMode.MEAN_REVERSION
        else:
            mode = VectorizationMode.ADAPTIVE

        # Calculate profit vector
        profit_vector = self.profit_vectorizer.calculate_profit_vector(
            vector_input, mode=mode
        )

        # Apply dualistic state adjustments
        profit_vector.profit_score *= dualistic_state["confidence_multiplier"]
        profit_vector.confidence_score *= dualistic_state["confidence_multiplier"]

        return profit_vector

    def _integrate_decision_components(
        self, market_data: MarketData, profit_vector: ProfitVector,
        dualistic_state: Dict[str, Any], expanded_strategy_id: int, phase_resolution: Any
    ) -> Dict[str, Any]:
        """
        Integrate all decision components to determine final trading action.
        """
        # Base decision logic
        action = "hold"
        confidence = 0.0
        profit_potential = 0.0

        # 1. Profit Vector Analysis
        if profit_vector.profit_score > 0.02:  # 2% minimum profit potential
            action = "buy"
            confidence = profit_vector.confidence_score
            profit_potential = profit_vector.profit_score
        elif profit_vector.profit_score < -0.02:  # Negative profit potential
            action = "sell"
            confidence = profit_vector.confidence_score
            profit_potential = abs(profit_vector.profit_score)

        # 2. Market Regime Analysis
        if market_data.trend_strength > 0.7 and action == "buy":
            confidence *= 1.2  # Boost confidence for strong trends
        elif market_data.trend_strength < 0.3 and action == "sell":
            confidence *= 1.1  # Boost confidence for strong downtrends

        # 3. Volatility Adjustment
        if market_data.volatility > 0.8:
            confidence *= 0.8  # Reduce confidence in high volatility
            profit_potential *= 1.3  # But increase profit potential

        # 4. Dualistic State Integration
        confidence *= dualistic_state["confidence_multiplier"]

        # 5. Bit Phase Precision
        if phase_resolution.bit_phase.value >= 16:
            confidence *= 1.1  # Higher precision = higher confidence
        elif phase_resolution.bit_phase.value <= 4:
            confidence *= 0.9  # Lower precision = lower confidence

        # 6. Strategy ID Pattern Analysis
        strategy_pattern = expanded_strategy_id % 256
        if strategy_pattern in [0, 64, 128, 192]:  # Special pattern values
            confidence *= 1.15  # Boost confidence for special patterns

        # Ensure confidence is within bounds
        confidence = max(0.1, min(1.0, confidence))

        return {
            "action": action,
            "confidence": confidence,
            "profit_potential": profit_potential,
            "dualistic_state": dualistic_state,
            "bit_phase": phase_resolution.bit_phase.value,
            "strategy_pattern": strategy_pattern
        }

    def _calculate_advanced_position_size(
        self, market_data: MarketData, decision_data: Dict[str, Any],
        profit_vector: ProfitVector, dualistic_state: Dict[str, Any]
    ) -> float:
        """
        Calculate advanced position size based on multiple factors.
        """
        # Base position size
        base_size = self.risk_params.max_position_size * self.state.current_capital

        # Price adjustment
        price = market_data.price
        if price <= 0:
            return 0.0

        # Volatility adjustment
        volatility_adjustment = 1.0 - (market_data.volatility * 0.5)

        # Confidence adjustment
        confidence_adjustment = decision_data["confidence"]

        # Profit potential adjustment
        profit_adjustment = min(profit_vector.profit_score * 10, 2.0)  # Cap at 2x

        # Dualistic state adjustment
        dualistic_adjustment = dualistic_state["confidence_multiplier"]

        # Thermal state adjustment
        thermal_multiplier = {
            ThermalState.COOL: 0.8,
            ThermalState.WARM: 1.0,
            ThermalState.HOT: 1.2,
        }.get(self.state.thermal_state, 1.0)

        # Calculate final position size
        adjusted_size = (base_size * volatility_adjustment * confidence_adjustment *
                        profit_adjustment * dualistic_adjustment * thermal_multiplier / price)

        # Ensure positive and reasonable size
        return max(0.0, min(adjusted_size, base_size * 2.0))  # Cap at 2x base size

    def _calculate_comprehensive_risk(
        self, market_data: MarketData, decision_data: Dict[str, Any],
        profit_vector: ProfitVector, quantity: float, dualistic_state: Dict[str, Any]
    ) -> Dict[str, float]:
        """
        Calculate comprehensive risk assessment.
        """
        # Volatility risk
        volatility_risk = market_data.volatility * 0.8

        # Position risk (based on position size relative to capital)
        position_risk = min((quantity * market_data.price) / self.state.current_capital, 1.0)

        # Strategy risk (based on confidence and profit potential)
        strategy_risk = 1.0 - decision_data["confidence"]

        # Market regime risk
        if market_data.trend_strength < 0.3:
            regime_risk = 0.6
        elif market_data.trend_strength > 0.7:
            regime_risk = 0.3
        else:
            regime_risk = 0.5

        # Dualistic state risk
        if dualistic_state["state"].endswith("_volatile"):
            dualistic_risk = 0.7
        else:
            dualistic_risk = 0.4

        # Overall risk (weighted average)
        overall_risk = (
            volatility_risk * 0.3 +
            position_risk * 0.25 +
            strategy_risk * 0.2 +
            regime_risk * 0.15 +
            dualistic_risk * 0.1
        )

        return {
            "overall_risk": overall_risk,
            "volatility_risk": volatility_risk,
            "position_risk": position_risk,
            "strategy_risk": strategy_risk,
            "regime_risk": regime_risk,
            "dualistic_risk": dualistic_risk
        }

    def _calculate_position_size(self, market_data: MarketData, action: str) -> float:
        """Calculate appropriate position size."""
        base_size = self.risk_params.max_position_size * self.state.current_capital
        price = market_data.price
        volatility_adjustment = 1.0 - market_data.volatility

        # Adjust for volatility
        adjusted_size = base_size * volatility_adjustment / price

        # Thermal state adjustment
        thermal_multiplier = {
            ThermalState.COOL: 0.8,
            ThermalState.WARM: 1.0,
            ThermalState.HOT: 1.2,
        }.get(self.state.thermal_state, 1.0)

        # Ensure positive quantity
        return max(0.0, adjusted_size * thermal_multiplier)

    def _calculate_portfolio_risk(self) -> float:
        """Calculate current portfolio risk level."""
        if len(self.decision_history) < 5:
            return 0.0

        recent_decisions = self.decision_history[-5:]
        risk_scores = [d.risk_score for d in recent_decisions]
        return np.mean(risk_scores)

    def _calculate_daily_pnl(self) -> float:
        """Calculate daily P&L."""
        today_start = time.time() - 24 * 3600  # 24 hours ago
        today_decisions = [d for d in self.decision_history if d.timestamp >= today_start]

        pnl = 0.0
        for decision in today_decisions:
            if decision.action == TradingAction.BUY:
                pnl -= decision.quantity * decision.price
            elif decision.action == TradingAction.SELL:
                pnl += decision.quantity * decision.price

        return pnl

    def _update_pipeline_state(self, decision: TradingDecision) -> None:
        """Update pipeline state after decision."""
        self.state.timestamp = decision.timestamp
        self.state.total_trades += 1

        # Update capital (simplified)
        if decision.action == TradingAction.BUY:
            self.state.current_capital -= decision.quantity * decision.price
        elif decision.action == TradingAction.SELL:
            self.state.current_capital += decision.quantity * decision.price

        # Update performance metrics
        self._update_pipeline_metrics()

    def _update_pipeline_metrics(self) -> None:
        """Update performance metrics."""
        if len(self.decision_history) < 2:
            return

        # Calculate basic metrics
        total_trades = len(self.decision_history)
        profitable_trades = len([d for d in self.decision_history if d.profit_potential > 0])

        self.performance_metrics["win_rate"] = (
            profitable_trades / total_trades if total_trades > 0 else 0
        )
        self.performance_metrics["total_return"] = (
            self.state.current_capital - self.initial_capital
        ) / self.initial_capital

    def get_pipeline_summary(self) -> Dict[str, Any]:
        """Get comprehensive pipeline summary."""
        return {
            "state": {
                "symbol": self.symbol,
                "current_capital": self.state.current_capital,
                "total_trades": self.state.total_trades,
                "active_strategy": self.state.active_strategy.value,
                "market_regime": self.state.market_regime.value,
                "thermal_state": self.state.thermal_state.value,
                "bit_phase": self.state.bit_phase.value,
            },
            "performance": self.performance_metrics,
            "risk_parameters": {
                "max_position_size": self.risk_params.max_position_size,
                "stop_loss_pct": self.risk_params.stop_loss_pct,
                "take_profit_pct": self.risk_params.take_profit_pct,
            },
            "history_length": {
                "market_data": len(self.market_data_history),
                "decisions": len(self.decision_history),
            },
        }


def create_trading_pipeline(
    symbol: str = "BTCUSDT", initial_capital: float = 10000.0
) -> CleanTradingPipeline:
    """Create a new trading pipeline instance."""
    return CleanTradingPipeline(symbol=symbol, initial_capital=initial_capital)


async def run_trading_simulation(
    pipeline: CleanTradingPipeline, market_data_stream: List[MarketData]
) -> Dict[str, Any]:
    """Run a trading simulation with provided market data."""
    decisions = []

    for market_data in market_data_stream:
        decision = await pipeline.process_market_data(market_data)
        if decision:
            decisions.append(decision)

    return {
        "total_decisions": len(decisions),
        "pipeline_summary": pipeline.get_pipeline_summary(),
        "final_capital": pipeline.state.current_capital,
        "total_return": (pipeline.state.current_capital - pipeline.initial_capital)
        / pipeline.initial_capital,
    }
